package com.github.davidyzliu.pytapycharmplugin.utils.reporttoolwindow

import com.github.davidyzliu.pytapycharmplugin.utils.PytaIssue
import com.github.davidyzliu.pytapycharmplugin.utils.PytaMessage
import com.intellij.openapi.ui.DialogPanel
import com.intellij.ui.layout.panel
import com.intellij.ui.treeStructure.Tree
import javax.swing.tree.MutableTreeNode

/**
 * Represents the Report Panel in the Tool Window for PythonTA.
 *
 * This Report Panel is used to display the results of the PythonTA scan to the user. If
 * no file is selected or no scan has been performed, then an appropriate message is
 * displayed to the user.
 * **/
class ReportToolWindowPanel {
    var toolWindowPanel: DialogPanel = panel {
        row {
            root("No report loaded...")()
        }
    }

    /**
     * Changes the content of the panel to display the provided list of PythonTA issues,
     * representing the results of a scan performed by the user
     * @param issues A list of PythonTA issues which represent the problems identified by PythonTA
     * **/
    fun addIssuesToPanel(issues: List<PytaIssue>) {
        toolWindowPanel.removeAll()
        toolWindowPanel.add(getParsedTree(issues))
    }

    /*
    * Creates a tree from the list of PythonTA issues to display to the user in the
    * Tool Window on the IDE.
    * */
    private fun getParsedTree(issues: List<PytaIssue>): Tree {

        return root("PyTA Report: report summary") {
            for (issue: PytaIssue in issues)
                file(issue) {
                    error(issue.msgs)
                    style(issue.msgs)
                }
        }
    }

    companion object {

        // the category names generated by the PythonTA JSONReporter.
        private const val ERROR_CATEGORY_NAME = "error"
        private const val STYLE_CATEGORY_NAME = "convention"


        /**
         * Formats file group node content
         */
        private fun parseFileContent(issue: PytaIssue): String {
            return issue.filename
        }

        /**
         * Formats error group node content
         */
        private fun parseErrorGroupContent(messages: Array<PytaMessage>): String {
            return "Errors: " + messages.filter { m -> isError(m) }.size + " errors"
        }

        /**
         * Formats error message leaf content
         */
        private fun parseErrorMessageContent(message: PytaMessage): String {
            return "Error: " + parseMessage(message)
        }

        /**
         * Formats style and convention group node content
         */
        private fun parseStyleGroupContent(messages: Array<PytaMessage>): String {
            return "Style and Convention: " + messages.filter { m -> isStyle(m) }.size + " style or convention warnings"
        }

        /**
         * Formats style and convention message leaf content
         */
        private fun parseStyleMessageContent(message: PytaMessage): String {
            return "Warning: " + parseMessage(message)
        }

        /**
         * Generic message format
         * Not structurally necessary nor useful, just reduces duplication.
         */
        private fun parseMessage(msg: PytaMessage): String {
            return "[${msg.symbol}] (${msg.line}:${msg.column}) ${msg.msg}"
        }


        /**
         * Declarative builder method for a scanned file which wraps the general [node] builder.
         * Has very little additional behavior and primarily serves to add a context-relevant name to the builder
         */
        fun MutableTreeNode.file(issue: PytaIssue, init: MutableTreeNode.() -> Unit = {}) {
            node(parseFileContent(issue), init)
        }

        /**
         * Declarative builder for error message group which wraps a collection of [node] builders.
         * @param messages  a list of messages of which only the errors will be displayed from
         */
        fun MutableTreeNode.error(messages: Array<PytaMessage>) {
            node(parseErrorGroupContent(messages)) {
                for (message: PytaMessage in messages)
                    if (isError(message))
                        node(parseErrorMessageContent(message))
            }
        }

        /**
         * Declarative builder for style and convention message group which wraps a collection of [node] builders.
         * @param messages  a list of messages of which only the style and convention warnings will be displayed from
         */
        fun MutableTreeNode.style(messages: Array<PytaMessage>) {
            node(parseStyleGroupContent(messages)) {
                for (message: PytaMessage in messages)
                    if (isStyle(message))
                        node(parseStyleMessageContent(message))
            }
        }

        private fun isError(message: PytaMessage): Boolean {
            return message.category == ERROR_CATEGORY_NAME
        }

        private fun isStyle(message: PytaMessage): Boolean {
            return message.category == STYLE_CATEGORY_NAME
        }
    }
}
